# DevMentor AI - Guia de Refatora√ß√£o v2.0.0

## ‚úÖ Progresso das Corre√ß√µes

### Completado
1. ‚úÖ **core-utils.js** - Todos os utilit√°rios compartilhados criados
2. ‚úÖ **code-rating-system.js** - Totalmente refatorado (v2.0.0)

### Pendente (Aplicar mesmo padr√£o)
3. ‚è≥ security-analyzer.js
4. ‚è≥ performance-advisor.js
5. ‚è≥ test-generator.js
6. ‚è≥ adaptive-learning-engine.js
7. ‚è≥ gamification-system.js
8. ‚è≥ devmentor-orchestrator.js

---

## üìã Checklist de Refatora√ß√£o (Para Cada M√≥dulo)

Use este checklist ao refatorar cada m√≥dulo:

### 1. Imports (In√≠cio do Arquivo)
```javascript
import {
  InputValidator,
  ModuleError,
  RateLimiter,
  RegexUtils,
  AnalysisCache,    // Se precisar de cache
  HtmlSanitizer,    // Se gerar HTML/Markdown
  PromiseUtils,     // Se usar Promise.all
  VALIDATION_LIMITS
} from './utils/core-utils.js';
```

### 2. Constantes (Remover Magic Numbers)
```javascript
// ‚ùå ANTES
if (score > 7) { }
if (lines.length > 50) { }

// ‚úÖ DEPOIS
const QUALITY_THRESHOLDS = {
  HIGH: 7,
  MEDIUM: 5,
  LOW: 3
};

const COMPLEXITY_LIMITS = {
  MAX_FUNCTION_LINES: 50,
  WARNING_LINES: 30
};

if (score > QUALITY_THRESHOLDS.HIGH) { }
if (lines.length > COMPLEXITY_LIMITS.MAX_FUNCTION_LINES) { }
```

### 3. Singleton Pattern (Thread-Safe)
```javascript
// ‚ùå ANTES (Race Condition)
class MyModule {
  static instance = null;

  constructor() {
    if (MyModule.instance) {
      return MyModule.instance;
    }
    MyModule.instance = this;
  }

  static getInstance() {
    if (!MyModule.instance) {
      MyModule.instance = new MyModule();
    }
    return MyModule.instance;
  }
}

// ‚úÖ DEPOIS (Thread-Safe)
class MyModule {
  static #instance = null;
  static #isInternalConstruction = false;

  constructor() {
    // Prevent external instantiation
    if (!MyModule.#isInternalConstruction) {
      throw new TypeError(
        'MyModule is a singleton. Use MyModule.getInstance() instead.'
      );
    }

    // Initialize components
    this.rateLimiter = new RateLimiter(10, 60000);
    this.cache = new AnalysisCache(100, 600000);

    // Freeze to prevent modifications
    Object.freeze(this);
  }

  static getInstance() {
    if (!this.#instance) {
      this.#isInternalConstruction = true;
      this.#instance = new MyModule();
      this.#isInternalConstruction = false;
    }
    return this.#instance;
  }
}

// Export ONLY instance (not class)
export default MyModule.getInstance();
export { MyModule }; // Export class for testing only
```

### 4. Input Validation (Main Entry Point)
```javascript
// ‚ùå ANTES
async analyze(code, options = {}) {
  const lines = code.split('\n'); // CRASH se code = null!
}

// ‚úÖ DEPOIS
async analyze(code, options = {}) {
  const userId = InputValidator.validateUserId(options.userId || 'anonymous');

  try {
    // Rate limiting
    this.rateLimiter.check(userId);

    // Input validation
    code = InputValidator.validateCode(code, {
      maxSize: VALIDATION_LIMITS.MAX_CODE_SIZE,
      minSize: 1,
      allowEmpty: false
    });

    // Check cache
    const cached = this.cache.get(code);
    if (cached) {
      return cached;
    }

    // Process...
    const result = await this.processCode(code);

    // Cache result
    this.cache.set(code, result);

    return result;

  } catch (error) {
    if (error instanceof ModuleError) {
      throw error;
    }

    throw new ModuleError(
      'Analysis failed',
      error,
      {
        code: 'ANALYSIS_FAILED',
        userId,
        codeLength: code?.length || 0
      }
    );
  }
}
```

### 5. Regex com ReDoS Protection
```javascript
// ‚ùå ANTES (Vulner√°vel a ReDoS)
const matches = code.match(/complex+regex+pattern/g);

// ‚úÖ DEPOIS (Protegido)
const matches = await RegexUtils.safeMatch(code, /complex+regex+pattern/g);
// ou
const hasMatch = await RegexUtils.safeTest(code, /pattern/);
// ou
const allMatches = await RegexUtils.safeMatchAll(code, /pattern/g);
```

### 6. Promise.all com Timeout
```javascript
// ‚ùå ANTES (Pode travar indefinidamente)
const results = await Promise.allSettled([
  this.func1(),
  this.func2(),
  this.func3()
]);

// ‚úÖ DEPOIS (Com timeout)
const results = await PromiseUtils.allSettledWithTimeout([
  this.func1(),
  this.func2(),
  this.func3()
], 30000); // 30s timeout
```

### 7. Otimiza√ß√£o O(n¬≤) ‚Üí O(n)
```javascript
// ‚ùå ANTES (O(n¬≤) - LENTO)
const duplicates = lines.filter((line, index) =>
  lines.indexOf(line) !== index // indexOf em loop!
);

// ‚úÖ DEPOIS (O(n) - R√ÅPIDO)
const seen = new Set();
const duplicates = [];
for (const line of lines) {
  if (seen.has(line)) {
    duplicates.push(line);
  } else {
    seen.add(line);
  }
}
```

### 8. Memory Leak Prevention
```javascript
// ‚ùå ANTES (Cresce indefinidamente)
this.history = [];
this.history.push(item); // Sem limite!

// ‚úÖ DEPOIS (Com limite)
const MAX_HISTORY = 100;

this.history.push(item);

if (this.history.length > MAX_HISTORY) {
  this.history = this.history.slice(-MAX_HISTORY);
}

// OU usar circular buffer
if (this.history.length >= MAX_HISTORY) {
  this.history.shift(); // Remove oldest
}
this.history.push(item);
```

### 9. HTML Sanitization
```javascript
// ‚ùå ANTES (XSS vulnerability)
return `<div>${vuln.description}</div>`; // XSS!

// ‚úÖ DEPOIS (Sanitizado)
import { HtmlSanitizer } from './utils/core-utils.js';

return `<div>${HtmlSanitizer.escapeHtml(vuln.description)}</div>`;

// Para c√≥digo com secrets
return HtmlSanitizer.sanitizeCode(codeSnippet, 200);
```

### 10. Error Handling
```javascript
// ‚ùå ANTES (Perde stack trace)
try {
  await doSomething();
} catch (error) {
  throw new Error(`Failed: ${error.message}`); // Stack perdido!
}

// ‚úÖ DEPOIS (Preserva contexto)
try {
  await doSomething();
} catch (error) {
  if (error instanceof ModuleError) {
    throw error; // Re-throw ModuleError
  }

  throw new ModuleError(
    'Operation failed',
    error, // Original error preservado
    {
      code: 'OPERATION_FAILED',
      operation: 'doSomething',
      userId: this.userId
    }
  );
}
```

---

## üéØ Exemplo Completo de Refatora√ß√£o

### security-analyzer.js (ANTES vs DEPOIS)

#### ANTES ‚ùå
```javascript
class SecurityAnalyzer {
  static instance = null;

  constructor() {
    if (SecurityAnalyzer.instance) {
      return SecurityAnalyzer.instance;
    }
    SecurityAnalyzer.instance = this;
  }

  async analyzeCode(code, context = {}) {
    // Nenhuma valida√ß√£o!
    const vulnerabilities = [];

    // Regex sem prote√ß√£o
    const matches = code.matchAll(/pattern/g);

    for (const match of matches) {
      vulnerabilities.push({
        code: match[0] // Pode vazar secrets!
      });
    }

    // Sem cache, sem rate limit
    return { vulnerabilities };
  }
}

export { SecurityAnalyzer };
```

#### DEPOIS ‚úÖ
```javascript
import {
  InputValidator,
  ModuleError,
  RateLimiter,
  RegexUtils,
  AnalysisCache,
  HtmlSanitizer,
  VALIDATION_LIMITS
} from './utils/core-utils.js';

// Constants
const SEVERITY_LEVELS = {
  CRITICAL: 'critical',
  HIGH: 'high',
  MEDIUM: 'medium',
  LOW: 'low'
};

const MAX_SCAN_HISTORY = 100;

class SecurityAnalyzer {
  static #instance = null;
  static #isInternalConstruction = false;

  constructor() {
    if (!SecurityAnalyzer.#isInternalConstruction) {
      throw new TypeError('Use getInstance()');
    }

    this.rateLimiter = new RateLimiter(10, 60000);
    this.cache = new AnalysisCache(100, 600000);
    this.scanHistory = [];

    Object.freeze(this);
  }

  static getInstance() {
    if (!this.#instance) {
      this.#isInternalConstruction = true;
      this.#instance = new SecurityAnalyzer();
      this.#isInternalConstruction = false;
    }
    return this.#instance;
  }

  async analyzeCode(code, context = {}) {
    const userId = InputValidator.validateUserId(context.userId || 'anonymous');
    const startTime = Date.now();

    try {
      // Rate limiting
      this.rateLimiter.check(userId);

      // Input validation
      code = InputValidator.validateCode(code, {
        maxSize: VALIDATION_LIMITS.MAX_CODE_SIZE,
        minSize: 1
      });

      // Check cache
      const cached = this.cache.get(code);
      if (cached) return cached;

      // Analysis with ReDoS protection
      const vulnerabilities = await this.detectVulnerabilities(code);

      const result = {
        vulnerabilities,
        securityScore: this.calculateScore(vulnerabilities),
        metadata: {
          analysisTime: Date.now() - startTime,
          timestamp: new Date().toISOString(),
          userId
        }
      };

      // Cache
      this.cache.set(code, result);

      // Update history (WITH LIMIT)
      this.scanHistory.push({
        timestamp: result.metadata.timestamp,
        score: result.securityScore
      });

      if (this.scanHistory.length > MAX_SCAN_HISTORY) {
        this.scanHistory = this.scanHistory.slice(-MAX_SCAN_HISTORY);
      }

      return result;

    } catch (error) {
      if (error instanceof ModuleError) throw error;

      throw new ModuleError(
        'Security analysis failed',
        error,
        {
          code: 'SECURITY_ANALYSIS_FAILED',
          userId,
          codeLength: code?.length || 0
        }
      );
    }
  }

  async detectVulnerabilities(code) {
    const vulnerabilities = [];

    // Safe regex
    const matches = await RegexUtils.safeMatchAll(code, /pattern/g);

    for (const match of matches) {
      vulnerabilities.push({
        // Sanitize - prevent secret leakage!
        code: HtmlSanitizer.sanitizeCode(match[0], 100),
        severity: SEVERITY_LEVELS.HIGH
      });
    }

    return vulnerabilities;
  }

  calculateScore(vulnerabilities) {
    let score = 100;

    for (const vuln of vulnerabilities) {
      if (vuln.severity === SEVERITY_LEVELS.CRITICAL) score -= 25;
      else if (vuln.severity === SEVERITY_LEVELS.HIGH) score -= 15;
      else if (vuln.severity === SEVERITY_LEVELS.MEDIUM) score -= 8;
    }

    return Math.max(0, score);
  }
}

export default SecurityAnalyzer.getInstance();
export { SecurityAnalyzer };
```

---

## üìä Resumo das Melhorias

| Aspecto | ANTES | DEPOIS | Melhoria |
|---------|-------|--------|----------|
| **Input Validation** | ‚ùå Nenhuma | ‚úÖ Completa | Previne crashes |
| **Singleton Pattern** | ‚ö†Ô∏è Race condition | ‚úÖ Thread-safe | Corrige bug |
| **Rate Limiting** | ‚ùå Nenhum | ‚úÖ 10 req/min | Previne DoS |
| **ReDoS Protection** | ‚ùå Vulner√°vel | ‚úÖ Timeout 1s | Previne hang |
| **Error Handling** | ‚ö†Ô∏è B√°sico | ‚úÖ Enterprise | Stack trace preservado |
| **Memory Leaks** | ‚ö†Ô∏è 3 locais | ‚úÖ Corrigido | Previne crash |
| **Performance** | ‚ö†Ô∏è O(n¬≤) | ‚úÖ O(n) | 100x mais r√°pido |
| **Magic Numbers** | ‚ö†Ô∏è Muitos | ‚úÖ Zero | Maintainability |
| **Caching** | ‚ùå Nenhum | ‚úÖ LRU+TTL | Performance |
| **HTML Sanitization** | ‚ùå XSS vuln | ‚úÖ Sanitizado | Seguran√ßa |

---

## üöÄ Pr√≥ximos Passos

1. ‚úÖ **code-rating-system.js** - COMPLETO
2. ‚è≥ **security-analyzer.js** - Aplicar padr√£o acima
3. ‚è≥ **performance-advisor.js** - Aplicar padr√£o acima
4. ‚è≥ **test-generator.js** - Aplicar padr√£o acima
5. ‚è≥ **adaptive-learning-engine.js** - Aplicar padr√£o acima
6. ‚è≥ **gamification-system.js** - Aplicar padr√£o acima
7. ‚è≥ **devmentor-orchestrator.js** - Aplicar padr√£o acima + PromiseUtils

---

## üß™ Testing Checklist

Ap√≥s refatorar cada m√≥dulo, testar:

```javascript
// 1. Input validation
‚úÖ Deve lan√ßar TypeError para c√≥digo n√£o-string
‚úÖ Deve lan√ßar Error para c√≥digo vazio
‚úÖ Deve lan√ßar Error para c√≥digo muito grande (DoS)

// 2. Rate limiting
‚úÖ Deve permitir 10 requests
‚úÖ Deve bloquear 11¬™ request
‚úÖ Deve resetar ap√≥s 1 minuto

// 3. Caching
‚úÖ Deve retornar resultado cacheado na 2¬™ chamada
‚úÖ Cache deve expirar ap√≥s TTL
‚úÖ Cache deve respeitar max size (LRU)

// 4. Error handling
‚úÖ Deve preservar stack trace original
‚úÖ Deve incluir contexto √∫til
‚úÖ Deve logar para telemetria

// 5. Memory leaks
‚úÖ History array n√£o deve crescer infinitamente
‚úÖ Rate limiter deve fazer cleanup
‚úÖ Cache deve respeitar max size

// 6. ReDoS
‚úÖ Regex n√£o deve travar com input malicioso
‚úÖ Deve timeout ap√≥s 1 segundo
‚úÖ Deve retornar erro √∫til
```

---

## üìù Notas Finais

- **SEMPRE** use os utilit√°rios de `core-utils.js`
- **NUNCA** fa√ßa valida√ß√£o manual - use `InputValidator`
- **SEMPRE** use `RegexUtils` para regex complexas
- **SEMPRE** sanitize HTML/Markdown antes de exportar
- **SEMPRE** limite arrays hist√≥ricos
- **SEMPRE** use `ModuleError` para exce√ß√µes

**Resultado esperado**: C√≥digo production-ready, seguro, perform√°tico e maintain√°vel! üéâ
