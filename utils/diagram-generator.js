/**
 * DevMentor AI - Diagram Generator
 * Sistema de geração automática de diagramas Mermaid
 * 
 * Funcionalidades:
 * - Análise automática de código para detectar padrões
 * - Geração de diagramas de fluxo (flowchart)
 * - Diagramas de sequência (sequence)
 * - Diagramas de classes (class)
 * - Diagramas de estado (state)
 * - Diagramas ER (entity-relationship)
 * - Integração com Mermaid.js
 */

class DiagramGenerator {
  constructor() {
    this.diagramTypes = {
      flowchart: this._generateFlowchart.bind(this),
      sequence: this._generateSequenceDiagram.bind(this),
      class: this._generateClassDiagram.bind(this),
      state: this._generateStateDiagram.bind(this),
      er: this._generateERDiagram.bind(this),
      gantt: this._generateGanttChart.bind(this),
      pie: this._generatePieChart.bind(this),
      gitgraph: this._generateGitGraph.bind(this)
    };
    
    this.patterns = {
      // Padrões para detectar fluxo de controle
      controlFlow: [
        /if\s*\(/,
        /else\s*{/,
        /for\s*\(/,
        /while\s*\(/,
        /switch\s*\(/,
        /case\s+/,
        /break\s*;/,
        /continue\s*;/
      ],
      
      // Padrões para detectar funções
      functions: [
        /function\s+\w+/,
        /const\s+\w+\s*=\s*\(/,
        /async\s+function/,
        /=>\s*{/,
        /def\s+\w+/,
        /class\s+\w+/
      ],
      
      // Padrões para detectar chamadas de função
      functionCalls: [
        /\w+\s*\(/,
        /await\s+\w+/,
        /\.then\s*\(/,
        /\.catch\s*\(/
      ],
      
      // Padrões para detectar classes
      classes: [
        /class\s+\w+/,
        /extends\s+\w+/,
        /implements\s+\w+/,
        /constructor\s*\(/,
        /public\s+/,
        /private\s+/,
        /protected\s+/
      ],
      
      // Padrões para detectar estados
      states: [
        /useState\s*\(/,
        /setState\s*\(/,
        /this\.state/,
        /state\s*=/,
        /status\s*=/
      ]
    };
    
    console.log('[DiagramGenerator] Inicializado com padrões de detecção');
  }

  /**
   * AUTO-DETECTAR E GERAR DIAGRAMA APROPRIADO
   * Analisa código e gera o tipo de diagrama mais relevante
   */
  async autoGenerateDiagram(code, analysis) {
    console.log('[DiagramGenerator] Analisando código para geração automática...');
    
    const diagramType = this._detectDiagramType(code, analysis);
    
    if (!diagramType) {
      console.warn('[DiagramGenerator] Nenhum tipo de diagrama detectado');
      return null;
    }
    
    console.log(`[DiagramGenerator] Tipo detectado: ${diagramType}`);
    
    const generator = this.diagramTypes[diagramType];
    const mermaidCode = await generator(code, analysis);
    
    return {
      type: diagramType,
      mermaidCode,
      rendered: await this._renderMermaid(mermaidCode),
      title: this._getDiagramTitle(diagramType, analysis),
      description: this._getDiagramDescription(diagramType, analysis)
    };
  }

  /**
   * DETECTAR TIPO DE DIAGRAMA
   * Analisa código para determinar o melhor tipo de diagrama
   */
  _detectDiagramType(code, analysis) {
    const scores = {
      flowchart: 0,
      sequence: 0,
      class: 0,
      state: 0,
      er: 0
    };
    
    // Análise de fluxo de controle
    const controlFlowMatches = this.patterns.controlFlow.filter(pattern => 
      pattern.test(code)
    ).length;
    scores.flowchart += controlFlowMatches * 2;
    
    // Análise de funções
    const functionMatches = this.patterns.functions.filter(pattern => 
      pattern.test(code)
    ).length;
    scores.sequence += functionMatches;
    scores.flowchart += functionMatches;
    
    // Análise de chamadas de função
    const callMatches = this.patterns.functionCalls.filter(pattern => 
      pattern.test(code)
    ).length;
    scores.sequence += callMatches * 1.5;
    
    // Análise de classes
    const classMatches = this.patterns.classes.filter(pattern => 
      pattern.test(code)
    ).length;
    scores.class += classMatches * 3;
    
    // Análise de estados
    const stateMatches = this.patterns.states.filter(pattern => 
      pattern.test(code)
    ).length;
    scores.state += stateMatches * 2;
    
    // Análise baseada no tipo de análise
    if (analysis === 'complexity') {
      scores.flowchart += 3;
    } else if (analysis === 'optimization') {
      scores.sequence += 2;
    } else if (analysis === 'security') {
      scores.sequence += 1;
    } else if (analysis === 'best_practices') {
      scores.class += 2;
    }
    
    // Retornar tipo com maior score
    const maxScore = Math.max(...Object.values(scores));
    if (maxScore === 0) return null;
    
    return Object.keys(scores).find(key => scores[key] === maxScore);
  }

  /**
   * GERAR DIAGRAMA DE FLUXO
   * Para algoritmos e controle de fluxo
   */
  _generateFlowchart(code, analysis) {
    console.log('[DiagramGenerator] Gerando flowchart...');
    
    const ast = this._parseCodeToAST(code);
    const nodes = this._extractFlowNodes(ast);
    
    let mermaid = 'flowchart TD\n';
    
    // Adicionar nós
    for (const node of nodes) {
      const nodeId = this._sanitizeNodeId(node.id);
      const nodeLabel = this._escapeLabel(node.label);
      
      mermaid += `  ${nodeId}["${nodeLabel}"]\n`;
      
      // Adicionar conexões
      for (const edge of node.edges) {
        const targetId = this._sanitizeNodeId(edge.target);
        const condition = edge.condition ? `|${this._escapeLabel(edge.condition)}|` : '';
        mermaid += `  ${nodeId} -->${condition} ${targetId}\n`;
      }
    }
    
    // Adicionar estilos
    mermaid += this._getFlowchartStyles(nodes);
    
    return mermaid;
  }

  /**
   * GERAR DIAGRAMA DE SEQUÊNCIA
   * Para interações entre funções/objetos
   */
  _generateSequenceDiagram(code, analysis) {
    console.log('[DiagramGenerator] Gerando sequence diagram...');
    
    const interactions = this._extractInteractions(code);
    
    let mermaid = 'sequenceDiagram\n';
    mermaid += '  autonumber\n';
    
    // Adicionar participantes
    for (const actor of interactions.actors) {
      mermaid += `  participant ${actor.id} as ${actor.name}\n`;
    }
    
    // Adicionar sequência de interações
    for (const interaction of interactions.sequence) {
      const arrow = interaction.async ? '->>+' : '->>';
      const message = this._escapeLabel(interaction.message);
      
      mermaid += `  ${interaction.from}${arrow}${interaction.to}: ${message}\n`;
      
      if (interaction.return) {
        const returnMsg = this._escapeLabel(interaction.return);
        mermaid += `  ${interaction.to}-->>-${interaction.from}: ${returnMsg}\n`;
      }
    }
    
    return mermaid;
  }

  /**
   * GERAR DIAGRAMA DE CLASSES
   * Para estruturas de classes e objetos
   */
  _generateClassDiagram(code, analysis) {
    console.log('[DiagramGenerator] Gerando class diagram...');
    
    const classes = this._extractClasses(code);
    
    let mermaid = 'classDiagram\n';
    
    // Adicionar classes
    for (const cls of classes) {
      mermaid += `  class ${cls.name} {\n`;
      
      // Adicionar propriedades
      for (const prop of cls.properties) {
        const visibility = prop.visibility || '+';
        mermaid += `    ${visibility}${prop.name}: ${prop.type}\n`;
      }
      
      // Adicionar métodos
      for (const method of cls.methods) {
        const visibility = method.visibility || '+';
        const params = method.parameters.join(', ');
        mermaid += `    ${visibility}${method.name}(${params}): ${method.returnType}\n`;
      }
      
      mermaid += '  }\n';
      
      // Adicionar relacionamentos
      for (const relation of cls.relationships) {
        mermaid += `  ${cls.name} ${relation.type} ${relation.target}\n`;
      }
    }
    
    return mermaid;
  }

  /**
   * GERAR DIAGRAMA DE ESTADO
   * Para máquinas de estado e transições
   */
  _generateStateDiagram(code, analysis) {
    console.log('[DiagramGenerator] Gerando state diagram...');
    
    const states = this._extractStates(code);
    
    let mermaid = 'stateDiagram-v2\n';
    
    // Adicionar estados
    for (const state of states) {
      mermaid += `  [*] --> ${state.name}\n`;
      
      for (const transition of state.transitions) {
        const condition = transition.condition ? ` : ${transition.condition}` : '';
        mermaid += `  ${state.name} --> ${transition.target}${condition}\n`;
      }
    }
    
    return mermaid;
  }

  /**
   * GERAR DIAGRAMA ER
   * Para relacionamentos entre entidades
   */
  _generateERDiagram(code, analysis) {
    console.log('[DiagramGenerator] Gerando ER diagram...');
    
    const entities = this._extractEntities(code);
    
    let mermaid = 'erDiagram\n';
    
    // Adicionar entidades
    for (const entity of entities) {
      mermaid += `  ${entity.name} {\n`;
      
      for (const attr of entity.attributes) {
        const key = attr.isKey ? 'PK' : '';
        const type = attr.type || 'string';
        mermaid += `    ${type} ${attr.name} ${key}\n`;
      }
      
      mermaid += '  }\n';
      
      // Adicionar relacionamentos
      for (const relation of entity.relationships) {
        mermaid += `  ${entity.name} ||--o{ ${relation.target} : "${relation.label}"\n`;
      }
    }
    
    return mermaid;
  }

  /**
   * GERAR GRÁFICO GANTT
   * Para cronogramas e dependências
   */
  _generateGanttChart(code, analysis) {
    console.log('[DiagramGenerator] Gerando Gantt chart...');
    
    const tasks = this._extractTasks(code);
    
    let mermaid = 'gantt\n';
    mermaid += '  title Cronograma de Execução\n';
    mermaid += '  dateFormat YYYY-MM-DD\n';
    mermaid += '  section Desenvolvimento\n';
    
    for (const task of tasks) {
      const start = task.start || '2024-01-01';
      const duration = task.duration || '1d';
      mermaid += `  ${task.name} : ${start}, ${duration}\n`;
    }
    
    return mermaid;
  }

  /**
   * GERAR GRÁFICO DE PIZZA
   * Para distribuições e proporções
   */
  _generatePieChart(code, analysis) {
    console.log('[DiagramGenerator] Gerando pie chart...');
    
    const data = this._extractPieData(code);
    
    let mermaid = 'pie title Distribuição\n';
    
    for (const item of data) {
      mermaid += `  "${item.label}" : ${item.value}\n`;
    }
    
    return mermaid;
  }

  /**
   * GERAR GRÁFICO GIT
   * Para fluxo de desenvolvimento
   */
  _generateGitGraph(code, analysis) {
    console.log('[DiagramGenerator] Gerando git graph...');
    
    const commits = this._extractCommits(code);
    
    let mermaid = 'gitgraph\n';
    
    for (const commit of commits) {
      mermaid += `  commit id: "${commit.message}"\n`;
    }
    
    return mermaid;
  }

  // Métodos auxiliares para análise de código
  _parseCodeToAST(code) {
    // Parser básico para extrair estrutura do código
    const lines = code.split('\n');
    const ast = {
      type: 'Program',
      body: []
    };
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line || line.startsWith('//') || line.startsWith('#')) continue;
      
      const node = this._parseLine(line, i);
      if (node) {
        ast.body.push(node);
      }
    }
    
    return ast;
  }

  _parseLine(line, lineNumber) {
    // Detectar tipos de linha
    if (line.includes('if(') || line.includes('if (')) {
      return {
        type: 'IfStatement',
        line: lineNumber,
        condition: this._extractCondition(line),
        body: []
      };
    } else if (line.includes('for(') || line.includes('for (')) {
      return {
        type: 'ForStatement',
        line: lineNumber,
        condition: this._extractCondition(line),
        body: []
      };
    } else if (line.includes('while(') || line.includes('while (')) {
      return {
        type: 'WhileStatement',
        line: lineNumber,
        condition: this._extractCondition(line),
        body: []
      };
    } else if (line.includes('function') || line.includes('=>')) {
      return {
        type: 'FunctionDeclaration',
        line: lineNumber,
        name: this._extractFunctionName(line),
        parameters: this._extractParameters(line)
      };
    } else if (line.includes('return')) {
      return {
        type: 'ReturnStatement',
        line: lineNumber,
        value: this._extractReturnValue(line)
      };
    }
    
    return null;
  }

  _extractFlowNodes(ast) {
    const nodes = [];
    let nodeId = 0;
    
    for (const statement of ast.body) {
      const node = {
        id: `node_${nodeId++}`,
        label: this._getNodeLabel(statement),
        type: statement.type,
        line: statement.line,
        edges: []
      };
      
      // Adicionar conexões baseadas no tipo
      if (statement.type === 'IfStatement') {
        node.edges.push({
          target: `node_${nodeId}`,
          condition: 'true'
        });
        node.edges.push({
          target: `node_${nodeId + 1}`,
          condition: 'false'
        });
      } else if (statement.type === 'ForStatement' || statement.type === 'WhileStatement') {
        node.edges.push({
          target: `node_${nodeId}`,
          condition: 'loop'
        });
        node.edges.push({
          target: `node_${nodeId + 1}`,
          condition: 'exit'
        });
      } else {
        node.edges.push({
          target: `node_${nodeId}`,
          condition: null
        });
      }
      
      nodes.push(node);
    }
    
    return nodes;
  }

  _extractInteractions(code) {
    const actors = new Set();
    const sequence = [];
    
    // Detectar funções e suas chamadas
    const functions = code.match(/(?:function|const|let|var)\s+(\w+)/g) || [];
    const calls = code.match(/\w+\s*\(/g) || [];
    
    // Adicionar atores
    functions.forEach(func => {
      const name = func.match(/(\w+)/)[1];
      actors.add({ id: name.toLowerCase(), name: name });
    });
    
    // Adicionar sequência
    calls.forEach(call => {
      const caller = 'main';
      const callee = call.replace('(', '').trim();
      
      sequence.push({
        from: caller,
        to: callee,
        message: `chama ${callee}()`,
        async: call.includes('await'),
        return: 'resultado'
      });
    });
    
    return {
      actors: Array.from(actors),
      sequence: sequence
    };
  }

  _extractClasses(code) {
    const classes = [];
    
    // Detectar classes JavaScript/TypeScript
    const classMatches = code.match(/class\s+(\w+)(?:\s+extends\s+(\w+))?/g) || [];
    
    classMatches.forEach(match => {
      const name = match.match(/class\s+(\w+)/)[1];
      const extendsClass = match.match(/extends\s+(\w+)/)?.[1];
      
      const cls = {
        name: name,
        properties: [],
        methods: [],
        relationships: []
      };
      
      if (extendsClass) {
        cls.relationships.push({
          type: '--|>',
          target: extendsClass
        });
      }
      
      classes.push(cls);
    });
    
    return classes;
  }

  _extractStates(code) {
    const states = [];
    
    // Detectar estados React
    const stateMatches = code.match(/useState\s*\(/g) || [];
    
    if (stateMatches.length > 0) {
      states.push({
        name: 'initial',
        transitions: [
          { target: 'loading', condition: 'fetch data' },
          { target: 'error', condition: 'error occurs' }
        ]
      });
      
      states.push({
        name: 'loading',
        transitions: [
          { target: 'success', condition: 'data loaded' },
          { target: 'error', condition: 'load failed' }
        ]
      });
    }
    
    return states;
  }

  _extractEntities(code) {
    // Detectar entidades em código
    const entities = [];
    
    // Padrões simples para detectar entidades
    const objectMatches = code.match(/const\s+(\w+)\s*=\s*{/g) || [];
    
    objectMatches.forEach(match => {
      const name = match.match(/const\s+(\w+)/)[1];
      entities.push({
        name: name,
        attributes: [
          { name: 'id', type: 'int', isKey: true },
          { name: 'name', type: 'string', isKey: false }
        ],
        relationships: []
      });
    });
    
    return entities;
  }

  _extractTasks(code) {
    // Extrair tarefas do código
    const tasks = [];
    const lines = code.split('\n');
    
    lines.forEach((line, index) => {
      if (line.includes('// TODO') || line.includes('// FIXME')) {
        tasks.push({
          name: line.replace(/\/\/\s*(TODO|FIXME):?\s*/, ''),
          start: '2024-01-01',
          duration: '1d'
        });
      }
    });
    
    return tasks;
  }

  _extractPieData(code) {
    // Extrair dados para gráfico de pizza
    const data = [];
    
    // Contar tipos de declarações
    const functions = (code.match(/function\s+\w+/g) || []).length;
    const variables = (code.match(/const\s+\w+/g) || []).length;
    const classes = (code.match(/class\s+\w+/g) || []).length;
    
    if (functions > 0) data.push({ label: 'Funções', value: functions });
    if (variables > 0) data.push({ label: 'Variáveis', value: variables });
    if (classes > 0) data.push({ label: 'Classes', value: classes });
    
    return data;
  }

  _extractCommits(code) {
    // Simular commits baseados no código
    return [
      { message: 'Initial commit' },
      { message: 'Add core functionality' },
      { message: 'Fix bugs' },
      { message: 'Add tests' }
    ];
  }

  // Métodos auxiliares para formatação
  _sanitizeNodeId(id) {
    return id.replace(/[^a-zA-Z0-9_]/g, '_');
  }

  _escapeLabel(label) {
    return label.replace(/"/g, '\\"').replace(/\n/g, '\\n');
  }

  _getNodeLabel(statement) {
    switch (statement.type) {
      case 'IfStatement':
        return `Se ${statement.condition}`;
      case 'ForStatement':
        return `Para ${statement.condition}`;
      case 'WhileStatement':
        return `Enquanto ${statement.condition}`;
      case 'FunctionDeclaration':
        return `Função ${statement.name}`;
      case 'ReturnStatement':
        return `Retorna ${statement.value}`;
      default:
        return statement.type;
    }
  }

  _getFlowchartStyles(nodes) {
    let styles = '\n';
    
    // Estilos para diferentes tipos de nós
    styles += '  classDef startEnd fill:#4CAF50,color:#fff\n';
    styles += '  classDef decision fill:#FF9800,color:#fff\n';
    styles += '  classDef process fill:#2196F3,color:#fff\n';
    styles += '  classDef function fill:#9C27B0,color:#fff\n';
    
    // Aplicar estilos aos nós
    nodes.forEach(node => {
      const nodeId = this._sanitizeNodeId(node.id);
      let className = 'process';
      
      if (node.type === 'IfStatement') className = 'decision';
      else if (node.type === 'FunctionDeclaration') className = 'function';
      else if (node.type === 'ReturnStatement') className = 'startEnd';
      
      styles += `  class ${nodeId} ${className}\n`;
    });
    
    return styles;
  }

  _getDiagramTitle(type, analysis) {
    const titles = {
      flowchart: 'Diagrama de Fluxo',
      sequence: 'Diagrama de Sequência',
      class: 'Diagrama de Classes',
      state: 'Diagrama de Estado',
      er: 'Diagrama Entidade-Relacionamento',
      gantt: 'Cronograma',
      pie: 'Gráfico de Distribuição',
      gitgraph: 'Histórico Git'
    };
    
    return titles[type] || 'Diagrama';
  }

  _getDiagramDescription(type, analysis) {
    const descriptions = {
      flowchart: 'Mostra o fluxo de execução e decisões do código',
      sequence: 'Ilustra as interações entre diferentes componentes',
      class: 'Representa a estrutura de classes e seus relacionamentos',
      state: 'Descreve os estados possíveis e suas transições',
      er: 'Modela as entidades e seus relacionamentos',
      gantt: 'Cronograma de tarefas e dependências',
      pie: 'Distribuição proporcional dos elementos',
      gitgraph: 'Histórico de desenvolvimento'
    };
    
    return descriptions[type] || 'Diagrama gerado automaticamente';
  }

  // Métodos auxiliares para extração de informações
  _extractCondition(line) {
    const match = line.match(/\(([^)]+)\)/);
    return match ? match[1] : 'condição';
  }

  _extractFunctionName(line) {
    const match = line.match(/(?:function\s+(\w+)|const\s+(\w+)\s*=)/);
    return match ? (match[1] || match[2]) : 'função';
  }

  _extractParameters(line) {
    const match = line.match(/\(([^)]*)\)/);
    return match ? match[1].split(',').map(p => p.trim()) : [];
  }

  _extractReturnValue(line) {
    const match = line.match(/return\s+(.+)/);
    return match ? match[1] : 'valor';
  }

  /**
   * RENDERIZAR DIAGRAMA MERMAID
   * Converte código Mermaid em SVG ou HTML
   */
  async _renderMermaid(mermaidCode) {
    // Verificar se Mermaid.js está disponível
    if (window.mermaid) {
      try {
        const { svg } = await window.mermaid.render('diagram', mermaidCode);
        return svg;
      } catch (error) {
        console.warn('[DiagramGenerator] Erro ao renderizar Mermaid:', error);
        return mermaidCode;
      }
    }
    
    // Fallback: retornar código para renderização client-side
    return mermaidCode;
  }

  /**
   * GERAR DIAGRAMA PERSONALIZADO
   * Permite especificar tipo e parâmetros
   */
  async generateCustomDiagram(type, code, options = {}) {
    if (!this.diagramTypes[type]) {
      throw new Error(`Tipo de diagrama não suportado: ${type}`);
    }
    
    const generator = this.diagramTypes[type];
    const mermaidCode = await generator(code, options.analysis || 'general');
    
    return {
      type,
      mermaidCode,
      rendered: await this._renderMermaid(mermaidCode),
      title: options.title || this._getDiagramTitle(type),
      description: options.description || this._getDiagramDescription(type)
    };
  }

  /**
   * OBTER TIPOS DISPONÍVEIS
   * Lista todos os tipos de diagrama suportados
   */
  getAvailableTypes() {
    return Object.keys(this.diagramTypes);
  }

  /**
   * VALIDAR CÓDIGO MERMAID
   * Verifica se o código Mermaid é válido
   */
  validateMermaidCode(mermaidCode) {
    try {
      // Validação básica
      if (!mermaidCode || typeof mermaidCode !== 'string') {
        return { valid: false, error: 'Código Mermaid inválido' };
      }
      
      // Verificar sintaxe básica
      const lines = mermaidCode.split('\n');
      const firstLine = lines[0].trim();
      
      const validTypes = ['flowchart', 'sequenceDiagram', 'classDiagram', 'stateDiagram', 'gantt', 'pie', 'gitgraph'];
      const isValidType = validTypes.some(type => firstLine.includes(type));
      
      if (!isValidType) {
        return { valid: false, error: 'Tipo de diagrama não reconhecido' };
      }
      
      return { valid: true };
      
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }
}

// Exportar para uso global
window.DiagramGenerator = DiagramGenerator;







